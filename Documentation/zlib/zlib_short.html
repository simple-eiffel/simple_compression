<!DOCTYPE html>
<html>
<head>
<meta name="generator" content="ISE EiffelStudio version 25.02.9.8732 - win64">
<meta name="description" content="Zlib API wrapper for operations provided by the c zlib library"/>
<meta name="keywords" content="Eiffel class"/>
<meta name="keywords" content="Eiffel class"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="https://fonts.googleapis.com/css?family=PT+Sans" rel="stylesheet">
<title>zlib Contracts</title>
<link rel="stylesheet" href="../default.css" type="text/css">
<script type="text/javascript" src="../goto.html"></script>
</head>
<body>
<pre></pre><form class="nav" onsubmit="go_to('../',this.c.value);return false;">
<div class="nav">
<a class="nav hierarchy" href="../class_list.html">Classes</a>
<a class="nav hierarchy" href="../cluster_list.html">Clusters</a>
<a class="nav hierarchy" href="../cluster_hierarchy.html">Cluster hierarchy</a>
<a class="nav class" href="zlib_chart.html">Chart</a>
<a class="nav class" href="zlib_links.html">Relations</a>
<span class="nav class selected">Contracts</span>
<span class="nav class goto">Go to: <input name="c" value="zlib"></span>
</div></form><pre><span class="ekeyword">note</span>
	<span class="eitag">description</span><span class="esymbol">:</span> <span class="estring">&quot;Zlib API wrapper for operations provided by the c zlib library&quot;</span>
	<span class="eitag">date</span><span class="esymbol">:</span> <span class="estring">&quot;$Date$&quot;</span>
	<span class="eitag">revision</span><span class="esymbol">:</span> <span class="estring">&quot;$Revision$&quot;</span>

<span class="ekeyword">class</span> <span class="ekeyword">interface</span>
	<a class="eclass" href="../zlib/zlib_short.html">ZLIB</a>

<span class="ekeyword">create</span> 
	<a class="efeature" href="../base/any_short.html#f_default_create">default_create</a>

<span class="ekeyword">feature</span> <span class="ecomment">--</span><span class="ecomment"> Status Report</span>

	<a name="f_last_operation"></a><a class="efeature" href="../zlib/zlib_short.html#f_last_operation">last_operation</a><span class="esymbol">:</span> <a class="eclass" href="../base/integer_32_short.html">INTEGER_32</a>
	
<span class="ekeyword">feature</span> <span class="ecomment">--</span><span class="ecomment"> Basic Functions</span>

	<a name="f_version"></a><a class="efeature" href="../zlib/zlib_short.html#f_version">version</a><span class="esymbol">:</span> <a class="eclass" href="../base/string_8_short.html">STRING_8</a>

	<a name="f_deflate"></a><a class="efeature" href="../zlib/zlib_short.html#f_deflate">deflate</a> <span class="esymbol">(</span><span class="elocal">a_stream</span><span class="esymbol">:</span> <a class="eclass" href="../zlib/zlib_stream_short.html">ZLIB_STREAM</a><span class="esymbol">;</span> <span class="elocal">a_flush</span><span class="esymbol">:</span> <a class="eclass" href="../base/natural_32_short.html">NATURAL_32</a><span class="esymbol">)</span>
			<span class="ecomment">--</span><span class="ecomment">	 &nbsp;deflate compresses as much data as possible, and stops when the input</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;buffer becomes empty or the output buffer becomes full. &nbsp;It may introduce</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;some output latency (reading input without producing any output) except when</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;forced to flush.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;The detailed semantics are as follows. &nbsp;deflate performs one or both of the</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;following actions:</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;- Compress more input starting at next_in and update next_in and avail_in</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;accordingly. &nbsp;If not all input can be processed (because there is not</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;enough room in the output buffer), next_in and avail_in are updated and</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;processing will resume at this point for the next call of deflate().</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;- Provide more output starting at next_out and update next_out and avail_out</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;accordingly. &nbsp;This action is forced if the parameter flush is non zero.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;Forcing flush frequently degrades the compression ratio, so this parameter</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;should be set only when necessary (in interactive applications). &nbsp;Some</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;output may be provided even if flush is not set.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;Before the call of deflate(), the application should ensure that at least</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;one of the actions is possible, by providing more input and/or consuming more</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;output, and updating avail_in or avail_out accordingly; avail_out should</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;never be zero before the call. &nbsp;The application can consume the compressed</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;output when it wants, for example when the output buffer is full (avail_out</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;== 0), or after each call of deflate(). &nbsp;If deflate returns Z_OK and with</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;zero avail_out, it must be called again after making room in the output</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;buffer because there might be more output pending.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;decide how much data to accumulate before producing output, in order to</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;maximize compression.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;If the parameter flush is set to Z_SYNC_FLUSH, all pending output is</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;flushed to the output buffer and the output is aligned on a byte boundary, so</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;that the decompressor can get all input data available so far. &nbsp;(In</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;particular avail_in is zero after the call if enough output space has been</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;provided before the call.) Flushing may degrade compression for some</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;compression algorithms and so it should be used only when necessary. &nbsp;This</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;completes the current deflate block and follows it with an empty stored block</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;that is three bits plus filler bits to the next byte, followed by four bytes</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;(00 00 ff ff).</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;If flush is set to Z_PARTIAL_FLUSH, all pending output is flushed to the</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;output buffer, but the output is not aligned to a byte boundary. &nbsp;All of the</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;input data so far will be available to the decompressor, as for Z_SYNC_FLUSH.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;This completes the current deflate block and follows it with an empty fixed</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;codes block that is 10 bits long. &nbsp;This assures that enough bytes are output</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;in order for the decompressor to finish the block before the empty fixed code</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;block.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;If flush is set to Z_BLOCK, a deflate block is completed and emitted, as</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;for Z_SYNC_FLUSH, but the output is not aligned on a byte boundary, and up to</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;seven bits of the current block are held to be written as the next byte after</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;the next deflate block is completed. &nbsp;In this case, the decompressor may not</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;be provided enough bits at this point in order to complete decompression of</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;the data provided so far to the compressor. &nbsp;It may need to wait for the next</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;block to be emitted. &nbsp;This is for advanced applications that need to control</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;the emission of deflate blocks.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;If flush is set to Z_FULL_FLUSH, all output is flushed as with</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;Z_SYNC_FLUSH, and the compression state is reset so that decompression can</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;restart from this point if previous compressed data has been damaged or if</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;random access is desired. &nbsp;Using Z_FULL_FLUSH too often can seriously degrade</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;compression.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;If deflate returns with avail_out == 0, this function must be called again</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;with the same value of the flush parameter and more output space (updated</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;avail_out), until the flush is complete (deflate returns with non-zero</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;avail_out). &nbsp;In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;avail_out is greater than six to avoid repeated flush markers due to</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;avail_out == 0 on return.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;If the parameter flush is set to Z_FINISH, pending input is processed,</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;pending output is flushed and deflate returns with Z_STREAM_END if there was</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;enough output space; if deflate returns with Z_OK, this function must be</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;called again with Z_FINISH and more output space (updated avail_out) but no</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;more input data, until it returns with Z_STREAM_END or an error. &nbsp;After</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;deflate has returned Z_STREAM_END, the only possible operations on the stream</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;are deflateReset or deflateEnd.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;Z_FINISH can be used immediately after deflateInit if all the compression</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;is to be done in a single step. &nbsp;In this case, avail_out must be at least the</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;value returned by deflateBound (see below). &nbsp;Then deflate is guaranteed to</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;return Z_STREAM_END. &nbsp;If not enough output space is provided, deflate will</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;not return Z_STREAM_END, and it must be called again as described above.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;deflate() sets strm-&gt;adler to the adler32 checksum of all input read</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;so far (that is, total_in bytes).</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;deflate() may update strm-&gt;data_type if it can make a good guess about</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;the input data type (Z_BINARY or Z_TEXT). &nbsp;In doubt, the data is considered</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;binary. &nbsp;This field is only for information purposes and does not affect the</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;compression algorithm in any manner.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;deflate() returns Z_OK if some progress has been made (more input</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;processed or more output produced), Z_STREAM_END if all input has been</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;consumed and all output has been produced (only when flush is set to</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;if next_in or next_out was Z_NULL), Z_BUF_ERROR if no progress is possible</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;(for example avail_in or avail_out was zero). &nbsp;Note that Z_BUF_ERROR is not</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;fatal, and deflate() can be called again with more input and more output</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;space to continue compressing.</span>
		<span class="ekeyword">require</span>
			<span class="etag">non_void_stream</span><span class="esymbol">:</span> <span class="elocal">a_stream</span> <span class="esymbol">/=</span> <span class="ekeyword">Void</span>

	<a name="f_deflate_end"></a><a class="efeature" href="../zlib/zlib_short.html#f_deflate_end">deflate_end</a> <span class="esymbol">(</span><span class="elocal">a_stream</span><span class="esymbol">:</span> <a class="eclass" href="../zlib/zlib_stream_short.html">ZLIB_STREAM</a><span class="esymbol">)</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;All dynamically allocated data structures for this stream are freed.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;This function discards any unprocessed input and does not flush any pending</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;output.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;&nbsp;deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;stream state was inconsistent, Z_DATA_ERROR if the stream was freed</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;prematurely (some input or output was discarded). &nbsp;In the error case, msg</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;may be set but then points to a static string (which must not be</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;deallocated).	</span>
		<span class="ekeyword">require</span>
			<span class="etag">non_void_stream</span><span class="esymbol">:</span> <span class="elocal">a_stream</span> <span class="esymbol">/=</span> <span class="ekeyword">Void</span>

	<a name="f_inflate"></a><a class="efeature" href="../zlib/zlib_short.html#f_inflate">inflate</a> <span class="esymbol">(</span><span class="elocal">a_stream</span><span class="esymbol">:</span> <a class="eclass" href="../zlib/zlib_stream_short.html">ZLIB_STREAM</a><span class="esymbol">;</span> <span class="elocal">a_flush</span><span class="esymbol">:</span> <a class="eclass" href="../base/natural_32_short.html">NATURAL_32</a><span class="esymbol">)</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;inflate decompresses as much data as possible, and stops when the input</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;buffer becomes empty or the output buffer becomes full. &nbsp;It may introduce</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;some output latency (reading input without producing any output) except when</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;forced to flush.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;The detailed semantics are as follows. &nbsp;inflate performs one or both of the</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;following actions:</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;- Decompress more input starting at next_in and update next_in and avail_in</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;accordingly. &nbsp;If not all input can be processed (because there is not</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;enough room in the output buffer), next_in is updated and processing will</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;resume at this point for the next call of inflate().</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;- Provide more output starting at next_out and update next_out and avail_out</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;accordingly. &nbsp;inflate() provides as much output as possible, until there is</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;no more input data or no more space in the output buffer (see below about</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;the flush parameter).</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;Before the call of inflate(), the application should ensure that at least</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;one of the actions is possible, by providing more input and/or consuming more</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;output, and updating the next_* and avail_* values accordingly. &nbsp;The</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;application can consume the uncompressed output when it wants, for example</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;when the output buffer is full (avail_out == 0), or after each call of</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;inflate(). &nbsp;If inflate returns Z_OK and with zero avail_out, it must be</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;called again after making room in the output buffer because there might be</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;more output pending.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FINISH,</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;Z_BLOCK, or Z_TREES. &nbsp;Z_SYNC_FLUSH requests that inflate() flush as much</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;output as possible to the output buffer. &nbsp;Z_BLOCK requests that inflate()</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;stop if and when it gets to the next deflate block boundary. &nbsp;When decoding</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;the zlib or gzip format, this will cause inflate() to return immediately</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;after the header and before the first block. &nbsp;When doing a raw inflate,</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;inflate() will go ahead and process the first block, and will return when it</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;gets to the end of that block, or when it runs out of data.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;The Z_BLOCK option assists in appending to or combining deflate streams.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;Also to assist in this, on return inflate() will set strm-&gt;data_type to the</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;number of unused bits in the last byte taken from strm-&gt;next_in, plus 64 if</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;inflate() is currently decoding the last block in the deflate stream, plus</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;128 if inflate() returned immediately after decoding an end-of-block code or</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;decoding the complete header up to just before the first byte of the deflate</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;stream. &nbsp;The end-of-block will not be indicated until all of the uncompressed</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;data from that block has been written to strm-&gt;next_out. &nbsp;The number of</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;unused bits may in general be greater than seven, except when bit 7 of</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;data_type is set, in which case the number of unused bits will be less than</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;eight. &nbsp;data_type is set as noted here every time inflate() returns for all</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;flush options, and so can be used to determine the amount of currently</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;consumed input in bits.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;The Z_TREES option behaves as Z_BLOCK does, but it also returns when the</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;end of each deflate block header is reached, before any actual data in that</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;block is decoded. &nbsp;This allows the caller to determine the length of the</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;deflate block header for later use in random access within a deflate block.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;256 is added to the value of strm-&gt;data_type when inflate() returns</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;immediately after reaching the end of the deflate block header.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;inflate() should normally be called until it returns Z_STREAM_END or an</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;error. &nbsp;However if all decompression is to be performed in a single step (a</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;single call of inflate), the parameter flush should be set to Z_FINISH. &nbsp;In</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;this case all pending input is processed and all pending output is flushed;</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;avail_out must be large enough to hold all of the uncompressed data for the</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;operation to complete. &nbsp;(The size of the uncompressed data may have been</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;saved by the compressor for this purpose.) The use of Z_FINISH is not</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;required to perform an inflation in one step. &nbsp;However it may be used to</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;inform inflate that a faster approach can be used for the single inflate()</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;call. &nbsp;Z_FINISH also informs inflate to not maintain a sliding window if the</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;stream completes, which reduces inflate's memory footprint. &nbsp;If the stream</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;does not complete, either because not all of the stream is provided or not</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;enough output space is provided, then a sliding window will be allocated and</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;inflate() can be called again to continue the operation as if Z_NO_FLUSH had</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;been used.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;&nbsp;In this implementation, inflate() always flushes as much output as</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;possible to the output buffer, and always uses the faster approach on the</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;first call. &nbsp;So the effects of the flush parameter in this implementation are</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;on the return value of inflate() as noted below, when inflate() returns early</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;when Z_BLOCK or Z_TREES is used, and when inflate() avoids the allocation of</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;memory for a sliding window when Z_FINISH is used.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;&nbsp;If a preset dictionary is needed after this call (see inflateSetDictionary</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;below), inflate sets strm-&gt;adler to the Adler-32 checksum of the dictionary</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;chosen by the compressor and returns Z_NEED_DICT; otherwise it sets</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;strm-&gt;adler to the Adler-32 checksum of all output produced so far (that is,</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;below. &nbsp;At the end of the stream, inflate() checks that its computed adler32</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;checksum is equal to that saved by the compressor and returns Z_STREAM_END</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;only if the checksum is correct.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;inflate() can decompress and check either zlib-wrapped or gzip-wrapped</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;deflate data. &nbsp;The header type is detected automatically, if requested when</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;initializing with inflateInit2(). &nbsp;Any information contained in the gzip</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;header is not retained, so applications that need that information should</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;instead use raw inflate, see inflateInit2() below, or inflateBack() and</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;perform their own processing of the gzip header and trailer. &nbsp;When processing</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;gzip-wrapped deflate data, strm-&gt;adler32 is set to the CRC-32 of the output</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;producted so far. &nbsp;The CRC-32 is checked against the gzip trailer.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;inflate() returns Z_OK if some progress has been made (more input processed</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;or more output produced), Z_STREAM_END if the end of the compressed data has</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;been reached and all uncompressed output has been produced, Z_NEED_DICT if a</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;preset dictionary is needed at this point, Z_DATA_ERROR if the input data was</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;corrupted (input stream not conforming to the zlib format or incorrect check</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;value), Z_STREAM_ERROR if the stream structure was inconsistent (for example</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;next_in or next_out was Z_NULL), Z_MEM_ERROR if there was not enough memory,</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;Z_BUF_ERROR if no progress is possible or if there was not enough room in the</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;output buffer when Z_FINISH is used. &nbsp;Note that Z_BUF_ERROR is not fatal, and</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;inflate() can be called again with more input and more output space to</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;continue decompressing. &nbsp;If Z_DATA_ERROR is returned, the application may</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;then call inflateSync() to look for a good compression block if a partial</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;recovery of the data is desired.	</span>
		<span class="ekeyword">require</span>
			<span class="etag">non_void_stream</span><span class="esymbol">:</span> <span class="elocal">a_stream</span> <span class="esymbol">/=</span> <span class="ekeyword">Void</span>

	<a name="f_inflate_end"></a><a class="efeature" href="../zlib/zlib_short.html#f_inflate_end">inflate_end</a> <span class="esymbol">(</span><span class="elocal">a_stream</span><span class="esymbol">:</span> <a class="eclass" href="../zlib/zlib_stream_short.html">ZLIB_STREAM</a><span class="esymbol">)</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;All dynamically allocated data structures for this stream are freed.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;This function discards any unprocessed input and does not flush any pending</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;output.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;&nbsp;inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;was inconsistent. &nbsp;In the error case, msg may be set but then points to a</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;static string (which must not be deallocated).</span>
		<span class="ekeyword">require</span>
			<span class="etag">non_void_stream</span><span class="esymbol">:</span> <span class="elocal">a_stream</span> <span class="esymbol">/=</span> <span class="ekeyword">Void</span>
	
<span class="ekeyword">feature</span> <span class="ecomment">--</span><span class="ecomment"> Utitlity Functions</span>

	<a name="f_compress"></a><a class="efeature" href="../zlib/zlib_short.html#f_compress">compress</a> <span class="esymbol">(</span><span class="elocal">a_target</span><span class="esymbol">,</span> <span class="elocal">a_target_len</span><span class="esymbol">,</span> <span class="elocal">a_source</span><span class="esymbol">:</span> <a class="eclass" href="../base/pointer_short.html">POINTER</a><span class="esymbol">;</span> <span class="elocal">a_source_len</span><span class="esymbol">:</span> <a class="eclass" href="../base/integer_32_short.html">INTEGER_32</a><span class="esymbol">)</span>
			<span class="ecomment">--</span><span class="ecomment">	 &nbsp;&nbsp;&nbsp;&nbsp;Compresses the source buffer into the destination buffer. &nbsp;sourceLen is</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;the byte length of the source buffer. &nbsp;Upon entry, destLen is the total size</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;of the destination buffer, which must be at least the value returned by</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;compressBound(sourceLen). &nbsp;Upon exit, destLen is the actual size of the</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;compressed buffer.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;&nbsp;compress returns Z_OK if success, Z_MEM_ERROR if there was not</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;enough memory, Z_BUF_ERROR if there was not enough room in the output</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;buffer.</span>

	<a name="f_uncompress"></a><a class="efeature" href="../zlib/zlib_short.html#f_uncompress">uncompress</a> <span class="esymbol">(</span><span class="elocal">a_target</span><span class="esymbol">,</span> <span class="elocal">a_target_len</span><span class="esymbol">,</span> <span class="elocal">a_source</span><span class="esymbol">:</span> <a class="eclass" href="../base/pointer_short.html">POINTER</a><span class="esymbol">;</span> <span class="elocal">a_source_len</span><span class="esymbol">:</span> <a class="eclass" href="../base/integer_32_short.html">INTEGER_32</a><span class="esymbol">)</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;&nbsp;Decompresses the source buffer into the destination buffer. &nbsp;sourceLen is</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;the byte length of the source buffer. &nbsp;Upon entry, destLen is the total size</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;of the destination buffer, which must be large enough to hold the entire</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;uncompressed data. &nbsp;(The size of the uncompressed data must have been saved</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;previously by the compressor and transmitted to the decompressor by some</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;mechanism outside the scope of this compression library.) Upon exit, destLen</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;is the actual size of the uncompressed buffer.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;&nbsp;uncompress returns Z_OK if success, Z_MEM_ERROR if there was not</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;enough memory, Z_BUF_ERROR if there was not enough room in the output</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete. &nbsp;In</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;the case where there is not enough room, uncompress() will fill the output</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;buffer with the uncompressed data up to that point.	</span>

	<a name="f_compress_bound"></a><a class="efeature" href="../zlib/zlib_short.html#f_compress_bound">compress_bound</a> <span class="esymbol">(</span><span class="elocal">a_source_len</span><span class="esymbol">:</span> <a class="eclass" href="../base/integer_32_short.html">INTEGER_32</a><span class="esymbol">)</span><span class="esymbol">:</span> <a class="eclass" href="../base/integer_32_short.html">INTEGER_32</a>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;&nbsp;compressBound() returns an upper bound on the compressed size after</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;compress() or compress2() on sourceLen bytes. &nbsp;It would be used before a</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;compress() or compress2() call to allocate the destination buffer.		</span>

	<a name="f_gzopen"></a><a class="efeature" href="../zlib/zlib_short.html#f_gzopen">gzopen</a> <span class="esymbol">(</span><span class="elocal">a_path</span><span class="esymbol">:</span> <a class="eclass" href="../base/readable_string_general_short.html">READABLE_STRING_GENERAL</a><span class="esymbol">;</span> <span class="elocal">a_mode</span><span class="esymbol">:</span> <a class="eclass" href="../base/string_8_short.html">STRING_8</a><span class="esymbol">)</span><span class="esymbol">:</span> <a class="eclass" href="../base/pointer_short.html">POINTER</a>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;Opens a gzip (.gz) file for reading or writing. &nbsp;The mode parameter is as</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;in fopen (&quot;rb&quot; or &quot;wb&quot;) but can also include a compression level (&quot;wb9&quot;) or</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;a strategy: 'f' for filtered data as in &quot;wb6f&quot;, 'h' for Huffman-only</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;compression as in &quot;wb1h&quot;, 'R' for run-length encoding as in &quot;wb1R&quot;, or 'F'</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;for fixed code compression as in &quot;wb9F&quot;. &nbsp;(See the description of</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;deflateInit2 for more information about the strategy parameter.) &nbsp;'T' will</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;request transparent writing or appending with no compression and not using</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;the gzip format.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;&nbsp;&quot;a&quot; can be used instead of &quot;w&quot; to request that the gzip stream that will</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;be written be appended to the file. &nbsp;&quot;+&quot; will result in an error, since</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;reading and writing to the same gzip file is not supported. &nbsp;The addition of</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&quot;x&quot; when writing will create the file exclusively, which fails if the file</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;already exists. &nbsp;On systems that support it, the addition of &quot;e&quot; when</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;reading or writing will set the flag to close the file on an execve() call.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;&nbsp;These functions, as well as gzip, will read and decode a sequence of gzip</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;streams in a file. &nbsp;The append function of gzopen() can be used to create</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;such a file. &nbsp;(Also see gzflush() for another way to do this.) &nbsp;When</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;appending, gzopen does not test whether the file begins with a gzip stream,</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;nor does it look for the end of the gzip streams to begin appending. &nbsp;gzopen</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;will simply append a gzip stream to the existing file.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;&nbsp;gzopen can be used to read a file which is not in gzip format; in this</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;case gzread will directly read from the file without decompression. &nbsp;When</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;reading, this will be detected automatically by looking for the magic two-</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;byte gzip header.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;&nbsp;gzopen returns NULL if the file could not be opened, if there was</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;insufficient memory to allocate the gzFile state, or if an invalid mode was</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;specified (an 'r', 'w', or 'a' was not provided, or '+' was provided).</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;errno can be checked to determine if the reason gzopen failed was that the</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;file could not be opened.</span>
		<span class="ekeyword">require</span>
			<span class="etag">non_void_path</span><span class="esymbol">:</span> <span class="elocal">a_path</span> <span class="esymbol">/=</span> <span class="ekeyword">Void</span>
			<span class="etag">non_void_mode</span><span class="esymbol">:</span> <span class="elocal">a_mode</span> <span class="esymbol">/=</span> <span class="ekeyword">Void</span>

	<a name="f_gzclose"></a><a class="efeature" href="../zlib/zlib_short.html#f_gzclose">gzclose</a> <span class="esymbol">(</span><span class="elocal">a_file</span><span class="esymbol">:</span> <a class="eclass" href="../base/pointer_short.html">POINTER</a><span class="esymbol">)</span>
			<span class="ecomment">--</span><span class="ecomment">	 Flushes all pending output if necessary, closes the compressed file and</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;deallocates the (de)compression state. &nbsp;Note that once file is closed, you</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;cannot call gzerror with file, since its structures have been deallocated.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;gzclose must not be called more than once on the same file, just as free</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;must not be called more than once on the same allocation.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;&nbsp;gzclose will return Z_STREAM_ERROR if file is not valid, Z_ERRNO on a</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;file operation error, Z_MEM_ERROR if out of memory, Z_BUF_ERROR if the</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;last read ended in the middle of a gzip stream, or Z_OK on success.		</span>

	<a name="f_gzwrite"></a><a class="efeature" href="../zlib/zlib_short.html#f_gzwrite">gzwrite</a> <span class="esymbol">(</span><span class="elocal">a_file</span><span class="esymbol">:</span> <a class="eclass" href="../base/pointer_short.html">POINTER</a><span class="esymbol">;</span> <span class="elocal">a_buffer</span><span class="esymbol">:</span> <a class="eclass" href="../base/pointer_short.html">POINTER</a><span class="esymbol">;</span> <span class="elocal">a_len</span><span class="esymbol">:</span> <a class="eclass" href="../base/integer_32_short.html">INTEGER_32</a><span class="esymbol">)</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;&nbsp;Writes the given number of uncompressed bytes into the compressed file.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;gzwrite returns the number of uncompressed bytes written or 0 in case of</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;error.</span>

	<a name="f_gzread"></a><a class="efeature" href="../zlib/zlib_short.html#f_gzread">gzread</a> <span class="esymbol">(</span><span class="elocal">a_file</span><span class="esymbol">:</span> <a class="eclass" href="../base/pointer_short.html">POINTER</a><span class="esymbol">;</span> <span class="elocal">a_buffer</span><span class="esymbol">:</span> <a class="eclass" href="../base/pointer_short.html">POINTER</a><span class="esymbol">;</span> <span class="elocal">a_len</span><span class="esymbol">:</span> <a class="eclass" href="../base/integer_32_short.html">INTEGER_32</a><span class="esymbol">)</span>
			<span class="ecomment">--</span><span class="ecomment">		 &nbsp;&nbsp;&nbsp;&nbsp;Reads the given number of uncompressed bytes from the compressed file. &nbsp;If</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;the input file is not in gzip format, gzread copies the given number of</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;bytes into the buffer directly from the file.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;&nbsp;After reaching the end of a gzip stream in the input, gzread will continue</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;to read, looking for another gzip stream. &nbsp;Any number of gzip streams may be</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;concatenated in the input file, and will all be decompressed by gzread().</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;If something other than a gzip stream is encountered after a gzip stream,</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;that remaining trailing garbage is ignored (and no error is returned).</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;&nbsp;gzread can be used to read a gzip file that is being concurrently written.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;Upon reaching the end of the input, gzread will return with the available</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;data. &nbsp;If the error code returned by gzerror is Z_OK or Z_BUF_ERROR, then</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;gzclearerr can be used to clear the end of file indicator in order to permit</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;gzread to be tried again. &nbsp;Z_OK indicates that a gzip stream was completed</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;on the last gzread. &nbsp;Z_BUF_ERROR indicates that the input file ended in the</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;middle of a gzip stream. &nbsp;Note that gzread does not return -1 in the event</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;of an incomplete gzip stream. &nbsp;This error is deferred until gzclose(), which</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;will return Z_BUF_ERROR if the last gzread ended in the middle of a gzip</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;stream. &nbsp;Alternatively, gzerror can be used before gzclose to detect this</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;case.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;&nbsp;gzread returns the number of uncompressed bytes actually read, less than</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;len for end of file, or -1 for error.</span>
	
<span class="ekeyword">feature</span> <span class="ecomment">--</span><span class="ecomment"> Helper Functions</span>

	<a name="f_inflate_init"></a><a class="efeature" href="../zlib/zlib_short.html#f_inflate_init">inflate_init</a> <span class="esymbol">(</span><span class="elocal">a_stream</span><span class="esymbol">:</span> <a class="eclass" href="../zlib/zlib_stream_short.html">ZLIB_STREAM</a><span class="esymbol">)</span>
		<span class="ekeyword">require</span>
			<span class="etag">non_void_stream</span><span class="esymbol">:</span> <span class="elocal">a_stream</span> <span class="esymbol">/=</span> <span class="ekeyword">Void</span>

	<a name="f_inflate_init_2"></a><a class="efeature" href="../zlib/zlib_short.html#f_inflate_init_2">inflate_init_2</a> <span class="esymbol">(</span><span class="elocal">a_stream</span><span class="esymbol">:</span> <a class="eclass" href="../zlib/zlib_stream_short.html">ZLIB_STREAM</a><span class="esymbol">;</span> <span class="elocal">a_windows_bits</span><span class="esymbol">:</span> <a class="eclass" href="../base/integer_32_short.html">INTEGER_32</a><span class="esymbol">)</span>
			<span class="ecomment">--</span><span class="ecomment"> 	This is another version of inflateInit with an extra parameter. &nbsp;The</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;fields next_in, avail_in, zalloc, zfree and opaque must be initialized</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;before by the caller.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;&nbsp;The windowBits parameter is the base two logarithm of the maximum window</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;size (the size of the history buffer). &nbsp;It should be in the range 8..15 for</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;this version of the library. &nbsp;The default value is 15 if inflateInit is used</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;instead. &nbsp;windowBits must be greater than or equal to the windowBits value</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;provided to deflateInit2() while compressing, or it must be equal to 15 if</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;deflateInit2() was not used. &nbsp;If a compressed stream with a larger window</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;size is given as input, inflate() will return with the error code</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;Z_DATA_ERROR instead of trying to allocate a larger window.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;&nbsp;windowBits can also be zero to request that inflate use the window size in</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;the zlib header of the compressed stream.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;&nbsp;windowBits can also be -8..-15 for raw inflate. &nbsp;In this case, -windowBits</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;determines the window size. &nbsp;inflate() will then process raw deflate data,</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;not looking for a zlib or gzip header, not generating a check value, and not</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;looking for any check values for comparison at the end of the stream. &nbsp;This</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;is for use with other formats that use the deflate compressed data format</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;such as zip. &nbsp;Those formats provide their own check values. &nbsp;If a custom</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;format is developed using the raw deflate format for compressed data, it is</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;recommended that a check value such as an adler32 or a crc32 be applied to</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;the uncompressed data as is done in the zlib, gzip, and zip formats. &nbsp;For</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;most applications, the zlib format should be used as is. &nbsp;Note that comments</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;above on the use in deflateInit2() applies to the magnitude of windowBits.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;&nbsp;windowBits can also be greater than 15 for optional gzip decoding. &nbsp;Add</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;32 to windowBits to enable zlib and gzip decoding with automatic header</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;detection, or add 16 to decode only the gzip format (the zlib format will</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;return a Z_DATA_ERROR). &nbsp;If a gzip stream is being decoded, strm-&gt;adler is a</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;crc32 instead of an adler32.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;&nbsp;inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;memory, Z_VERSION_ERROR if the zlib library version is incompatible with the</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;version assumed by the caller, or Z_STREAM_ERROR if the parameters are</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;invalid, such as a null pointer to the structure. &nbsp;msg is set to null if</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;there is no error message. &nbsp;inflateInit2 does not perform any decompression</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;apart from possibly reading the zlib header if present: actual decompression</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;will be done by inflate(). &nbsp;(So next_in and avail_in may be modified, but</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;next_out and avail_out are unused and unchanged.) The current implementation</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;of inflateInit2() does not process any header information -- that is</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;deferred until inflate() is called.	</span>
		<span class="ekeyword">require</span>
			<span class="etag">non_void_stream</span><span class="esymbol">:</span> <span class="elocal">a_stream</span> <span class="esymbol">/=</span> <span class="ekeyword">Void</span>

	<a name="f_deflate_init"></a><a class="efeature" href="../zlib/zlib_short.html#f_deflate_init">deflate_init</a> <span class="esymbol">(</span><span class="elocal">a_stream</span><span class="esymbol">:</span> <a class="eclass" href="../zlib/zlib_stream_short.html">ZLIB_STREAM</a><span class="esymbol">;</span> <span class="elocal">a_level</span><span class="esymbol">:</span> <a class="eclass" href="../base/integer_32_short.html">INTEGER_32</a><span class="esymbol">)</span>
		<span class="ekeyword">require</span>
			<span class="etag">non_void_stream</span><span class="esymbol">:</span> <span class="elocal">a_stream</span> <span class="esymbol">/=</span> <span class="ekeyword">Void</span>
			<span class="etag">known_level</span><span class="esymbol">:</span> <span class="elocal">a_level</span> <a class="esymbol" href="../base/comparable_short.html#f_is_greater_equal">&gt;=</a> <a class="efeature" href="../zlib/zlib_constants_short.html#f_z_default_compression">Z_default_compression</a> <a class="ekeyword" href="../base/boolean_short.html#f_conjuncted_semistrict">and then</a> <span class="elocal">a_level</span> <a class="esymbol" href="../base/comparable_short.html#f_is_less_equal">&lt;=</a> <a class="efeature" href="../zlib/zlib_constants_short.html#f_z_best_compression">Z_best_compression</a>

	<a name="f_deflate_init_2"></a><a class="efeature" href="../zlib/zlib_short.html#f_deflate_init_2">deflate_init_2</a> <span class="esymbol">(</span><span class="elocal">a_stream</span><span class="esymbol">:</span> <a class="eclass" href="../zlib/zlib_stream_short.html">ZLIB_STREAM</a><span class="esymbol">;</span> <span class="elocal">a_level</span><span class="esymbol">:</span> <a class="eclass" href="../base/integer_32_short.html">INTEGER_32</a><span class="esymbol">;</span> <span class="elocal">a_method</span><span class="esymbol">:</span> <a class="eclass" href="../base/integer_32_short.html">INTEGER_32</a><span class="esymbol">;</span> <span class="elocal">a_windowbits</span><span class="esymbol">:</span> <a class="eclass" href="../base/integer_32_short.html">INTEGER_32</a><span class="esymbol">;</span> <span class="elocal">a_memlevel</span><span class="esymbol">:</span> <a class="eclass" href="../base/integer_32_short.html">INTEGER_32</a><span class="esymbol">;</span> <span class="elocal">a_strategy</span><span class="esymbol">:</span> <a class="eclass" href="../base/integer_32_short.html">INTEGER_32</a><span class="esymbol">)</span>
			<span class="ecomment">--</span><span class="ecomment">		 &nbsp;&nbsp;&nbsp;&nbsp;This is another version of deflateInit with more compression options. &nbsp;The</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;fields next_in, zalloc, zfree and opaque must be initialized before by the</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;caller.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;&nbsp;The method parameter is the compression method. &nbsp;It must be Z_DEFLATED in</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;this version of the library.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;&nbsp;The windowBits parameter is the base two logarithm of the window size</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;(the size of the history buffer). &nbsp;It should be in the range 8..15 for this</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;version of the library. &nbsp;Larger values of this parameter result in better</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;compression at the expense of memory usage. &nbsp;The default value is 15 if</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;deflateInit is used instead.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;&nbsp;windowBits can also be -8..-15 for raw deflate. &nbsp;In this case, -windowBits</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;determines the window size. &nbsp;deflate() will then generate raw deflate data</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;with no zlib header or trailer, and will not compute an adler32 check value.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;&nbsp;windowBits can also be greater than 15 for optional gzip encoding. &nbsp;Add</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;16 to windowBits to write a simple gzip header and trailer around the</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;compressed data instead of a zlib wrapper. &nbsp;The gzip header will have no</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;file name, no extra data, no comment, no modification time (set to zero), no</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;header crc, and the operating system will be set to 255 (unknown). &nbsp;If a</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;gzip stream is being written, strm-&gt;adler is a crc32 instead of an adler32.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;&nbsp;The memLevel parameter specifies how much memory should be allocated</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;for the internal compression state. &nbsp;memLevel=1 uses minimum memory but is</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;slow and reduces compression ratio; memLevel=9 uses maximum memory for</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;optimal speed. &nbsp;The default value is 8. &nbsp;See zconf.h for total memory usage</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;as a function of windowBits and memLevel.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;&nbsp;The strategy parameter is used to tune the compression algorithm. &nbsp;Use the</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;string match), or Z_RLE to limit match distances to one (run-length</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;encoding). &nbsp;Filtered data consists mostly of small values with a somewhat</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;random distribution. &nbsp;In this case, the compression algorithm is tuned to</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;compress them better. &nbsp;The effect of Z_FILTERED is to force more Huffman</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;coding and less string matching; it is somewhat intermediate between</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY. &nbsp;Z_RLE is designed to be almost as</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;fast as Z_HUFFMAN_ONLY, but give better compression for PNG image data. &nbsp;The</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;strategy parameter only affects the compression ratio but not the</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;correctness of the compressed output even if it is not set appropriately.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;Z_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;decoder for special applications.</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;&nbsp;&nbsp;deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;memory, Z_STREAM_ERROR if any parameter is invalid (such as an invalid</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;method), or Z_VERSION_ERROR if the zlib library version (zlib_version) is</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;incompatible with the version assumed by the caller (ZLIB_VERSION). &nbsp;msg is</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;set to null if there is no error message. &nbsp;deflateInit2 does not perform any</span>
			<span class="ecomment">--</span><span class="ecomment"> &nbsp;&nbsp;compression: this will be done by deflate().</span>
			<span class="ecomment">--</span><span class="ecomment">*/</span>
		<span class="ekeyword">require</span>
			<span class="etag">non_void_stream</span><span class="esymbol">:</span> <span class="elocal">a_stream</span> <span class="esymbol">/=</span> <span class="ekeyword">Void</span>
			<span class="etag">known_level</span><span class="esymbol">:</span> <span class="elocal">a_level</span> <a class="esymbol" href="../base/comparable_short.html#f_is_greater_equal">&gt;=</a> <a class="efeature" href="../zlib/zlib_constants_short.html#f_z_default_compression">Z_default_compression</a> <a class="ekeyword" href="../base/boolean_short.html#f_conjuncted_semistrict">and then</a> <span class="elocal">a_level</span> <a class="esymbol" href="../base/comparable_short.html#f_is_less_equal">&lt;=</a> <a class="efeature" href="../zlib/zlib_constants_short.html#f_z_best_compression">Z_best_compression</a>
	
<span class="ekeyword">end</span> <span class="ecomment">--</span> <span class="ecomment">class </span><a class="eclass" href="../zlib/zlib_short.html">ZLIB</a></pre><form class="nav" onsubmit="go_to('../',this.c.value);return false;">
<div class="nav">
<a class="nav hierarchy" href="../class_list.html">Classes</a>
<a class="nav hierarchy" href="../cluster_list.html">Clusters</a>
<a class="nav hierarchy" href="../cluster_hierarchy.html">Cluster hierarchy</a>
<a class="nav class" href="zlib_chart.html">Chart</a>
<a class="nav class" href="zlib_links.html">Relations</a>
<span class="nav class selected">Contracts</span>
<span class="nav class goto">Go to: <input name="c" value="zlib"></span>
</div></form><pre></pre>
<p style="text-align:center;">Generated by <a href="http://www.eiffel.com">ISE EiffelStudio</a></p>
</body>
</html>

